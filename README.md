观察编码字符串的特点：`k[encoded_string]`。

1.  **括号是成对的**
2.  **`k[encoded_string]`是可以嵌套的**
3.  **上下文的保存与恢复**：当我们进入一个深层括号 `[` 时，我们需要“记住”外层是什么样的（比如，外层已经拼接好的字符串和外层的重复次数）。当我们处理完这个括号 `]` 并返回到外层时，我们需要“恢复”之前的状态，并把刚刚解码好的子字符串应用上去。

这种“后进先出或者先进后出”的上下文管理模式，第一感觉就是可以使用 **`栈`** 或者 **`递归`**

---

### 解题思路：使用栈

这是最直观、也是最通用的解法，它通过模拟解码的过程来解决问题，不会有递归层数过深的风险。

我们需要两个栈来协同工作：

*   `numStack` (数字栈)：专门用来存放待处理的重复次数 `k`。
*   `strStack` (字符串栈)：专门用来存放在遇到 `[` 时，它外层的、已经拼接好的字符串。

#### 算法流程：

1.  初始化两个栈：`numStack` 和 `strStack`。
2.  初始化两个变量：
    *   `current_num`：一个整型，用来记录当前遇到的数字（因为数字可能是多位数，如 `100[...]`）。
    *   `current_str`：一个字符串，用来累加当前层级解码出来的结果。
3.  从左到右遍历输入的字符串 `s` 的每一个字符：

    *   **如果遇到数字**：
        *   更新 `current_num`。例如，字符是 '3'，`current_num` 就变成 3。如果下一个字符是 '5'，`current_num` 就变成 `3*10 + 5 = 35`。

    *   **如果遇到 `[`**：
        *   这是一个“进入下一层”的信号。我们需要**保存当前的状态**。
        *   将 `current_num` 压入 `numStack`。
        *   将 `current_str` 压入 `strStack`。
        *   **重置** `current_num = 0` 和 `current_str = ""`，为解码这个新层级做准备。

    *   **如果遇到字母**：
        *   这是最简单的情况，直接将这个字母拼接到 `current_str` 的末尾。

    *   **如果遇到 `]`**：
        *   这是一个“完成当前层，返回上一层”的信号。我们需要**恢复之前的状态并进行计算**。
        *   从 `numStack` 弹出一个数字 `k`。
        *   从 `strStack` 弹出一个字符串 `prev_str` (这是上一层的字符串)。
        *   将当前的 `current_str` 重复 `k` 次。
        *   将重复后的字符串，拼接到 `prev_str` 的后面，形成新的 `current_str`。

4.  遍历结束后，`current_str` 中存储的就是最终的解码结果。
